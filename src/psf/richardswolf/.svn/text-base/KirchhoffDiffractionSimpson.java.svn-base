//=====================================================================================
// Project: PSF Generator
// 
// Author: 
// Daniel Sage
// Biomedical Imaging Group (BIG)
// Ecole Polytechnique Federale de Lausanne (EPFL)
// Lausanne, Switzerland
//
// Information: http://bigwww.epfl.ch/deconvolution/
//
// Reference:
// Alessandra Griffa, Nathalie Garin, Daniel Sage, 
// Comparison of Deconvolution Software in 3D Microscopy: A User Point of View
// G.I.T. Imaging & Microscopy, vol. 12, no. 1, pp. 43-45, March 2010.
// Available: http://bigwww.epfl.ch/publications/griffa1001.html
//
// Conditions of use:
// You'll be free to use this software for research purposes, but you
// should not redistribute it without our consent. In addition, we 
// expect you to include a citation or acknowledgment whenever 
// you present or publish results that are based on it.
//=====================================================================================

package psf.rw;

import psf.utils.Bessel;

/**
 * Kirchhoff Diffraction integral formula for the Richards and Wolf vectorial PSF model
 * 
 * @author Hagai Kirshner, Biomedical Imaging Group, Ecole Polytechnique Federale de Lausanne (EPFL)
 */
public class KirchhoffDiffractionSimpson{

	// Richards & Wolf parameters of the acquisition
	private RichardsWolfParameters p;
	
	// Stopping conditions:
	// Difference between consecutive approximations.
	double TOL = 1E-1;
	// The number of consecutive approximations that meet the TOL criterion
	int K;
	

	// Constructor
	public KirchhoffDiffractionSimpson(RichardsWolfParameters p, int accuracy) {
		this.p = p;
		if (accuracy == 0) K = 5;
		else if (accuracy == 1) K = 7;
		else if (accuracy == 2) K = 9;
		else K = 3;
	}
	
	// calculate()
	// Simpson approximation for the Kirchhoff diffraction integral
	// 'r' is the radial distance of the detector relative to the optical axis.
	double calculate(double r) {

		int N;	// number of sub-intervals
		int k; // number of consecutive successful approximations
		double del;		// integration interval
		int iteration;	// number of iterations.
		double curDifference; // Stopping criterion
		
		double realSumI0, realSumI1, realSumI2;
		double imagSumI0, imagSumI1, imagSumI2;
		double rho;
		
		// The real part of I9 is in value[0][0], the imaginary part of I0 is in value[0][1]
		// The real part of I9 is in value[1][0], the imaginary part of I0 is in value[1][1]
		// The real part of I9 is in value[2][0], the imaginary part of I0 is in value[2][1]
		// The same holds for the intermediate sums sumOddIndex and sumEvenIndex
		double[][] value = new double[3][2];
		double[][] valuea = new double[3][2], valueb = new double[3][2];
		double[][] sumOddIndex = new double[3][2], sumEvenIndex = new double[3][2];
		
		double curI = 0.0, prevI = 0.0;
		double a,b;	// Integration limits
		
		// Initialization of the three Simpson sums for I0, I1 and I2
		a=0.0;
		b = Math.asin(p.NA/p.ni); // This is alpha in equation (3) of the paper
		N=2;
		del=b/2.0;
		k=0;
		iteration = 1;
		rho = b/2.0;
		sumOddIndex = this.integrand(rho,r);
		for (int m=0;m<3;m++)
			for(int n=0;n<2;n++) 
				sumEvenIndex[m][n] = 0.0;		
		valuea = this.integrand(a,r);
		valueb = this.integrand(b,r);
		realSumI0 = valuea[0][0] + 2.0*sumEvenIndex[0][0] + 4.0*sumOddIndex[0][0] + valueb[0][0];
		imagSumI0 = valuea[0][1] + 2.0*sumEvenIndex[0][1] + 4.0*sumOddIndex[0][1] + valueb[0][1];
		realSumI1 = valuea[1][0] + 2.0*sumEvenIndex[1][0] + 4.0*sumOddIndex[1][0] + valueb[1][0];
		imagSumI1 = valuea[1][1] + 2.0*sumEvenIndex[1][1] + 4.0*sumOddIndex[1][1] + valueb[1][1];
		realSumI2 = valuea[2][0] + 2.0*sumEvenIndex[2][0] + 4.0*sumOddIndex[2][0] + valueb[2][0];
		imagSumI2 = valuea[2][1] + 2.0*sumEvenIndex[2][1] + 4.0*sumOddIndex[2][1] + valueb[2][1];
		curI = (realSumI0*realSumI0+imagSumI0*imagSumI0 + 2*(realSumI1*realSumI1+imagSumI1*imagSumI1) + realSumI2*realSumI2+imagSumI2*imagSumI2)*del*del;
		
		prevI=curI;
		curDifference = TOL;
								
		// Finer sampling grid until we meet the TOL value with the specified number of repetitions, K
		while(k<K) {
			iteration++;
			N *= 2;
			del = del/2;
			for (int m=0;m<3;m++) {
				for(int n=0;n<2;n++) {
					sumEvenIndex[m][n] += sumOddIndex[m][n];
					sumOddIndex[m][n] = 0.0;
				}
			}
			//sumEvenIndex[0] = sumEvenIndex[0] + sumOddIndex[0];
			//sumEvenIndex[1] = sumEvenIndex[1] + sumOddIndex[1];
			//sumOddIndex[0] = 0.0;
			//sumOddIndex[1] = 0.0;
			for(int n=1; n<N; n=n+2) {
				rho = n*del;
				value = this.integrand(rho,r);
				for (int mm=0;mm<3;mm++) 
					for(int nn=0;nn<2;nn++)
						sumOddIndex[mm][nn] += value[mm][nn];
						
				//sumOddIndex[0] += value[0]; 
				//sumOddIndex[1] += value[1];
			}
			//realSum = valueX0[0] + 2.0*sumEvenIndex[0] + 4.0*sumOddIndex[0] + valueXn[0];
			//imagSum = valueX0[1] + 2.0*sumEvenIndex[1] + 4.0*sumOddIndex[1] + valueXn[1];
			//curI = (realSum*realSum+imagSum*imagSum)*del*del;
			realSumI0 = valuea[0][0] + 2.0*sumEvenIndex[0][0] + 4.0*sumOddIndex[0][0] + valueb[0][0];
			imagSumI0 = valuea[0][1] + 2.0*sumEvenIndex[0][1] + 4.0*sumOddIndex[0][1] + valueb[0][1];
			realSumI1 = valuea[1][0] + 2.0*sumEvenIndex[1][0] + 4.0*sumOddIndex[1][0] + valueb[1][0];
			imagSumI1 = valuea[1][1] + 2.0*sumEvenIndex[1][1] + 4.0*sumOddIndex[1][1] + valueb[1][1];
			realSumI2 = valuea[2][0] + 2.0*sumEvenIndex[2][0] + 4.0*sumOddIndex[2][0] + valueb[2][0];
			imagSumI2 = valuea[2][1] + 2.0*sumEvenIndex[2][1] + 4.0*sumOddIndex[2][1] + valueb[2][1];
			curI = (realSumI0*realSumI0+imagSumI0*imagSumI0 + 2*(realSumI1*realSumI1+imagSumI1*imagSumI1) + realSumI2*realSumI2+imagSumI2*imagSumI2)*del*del;
	
			// Relative error between consecutive approximations
			if (prevI==0.0) curDifference = Math.abs((prevI-curI)/1E-5);
			else curDifference = Math.abs((prevI-curI)/curI);
			
			if (curDifference<=TOL)  k++;
			else k = 0;
			
			prevI=curI;
		}
		
		return curI;
}
	
	double[][] integrand(double theta, double r) {
		
		// 'theta' is the integration parameter.
		// 'r' is the radial distance of the detector relative to the optical axis.
		// NA is assumed to be less than 1.0, i.e. it assumed to be already normalized by the refractive index of the immersion layer, ni.
		// The return value is a complex number.
		
		double sinTheta = Math.sin(theta);
		double cosTheta = Math.cos(theta);
		//double sinThetaSinTheta = sinTheta*sinTheta;
		double sqrtCosThetaSinTheta = Math.sqrt(cosTheta)*sinTheta;
		//double niNiSinThetaSinTheta = p.ni*p.ni*sinThetaSinTheta;
		
	
		// Fresnel coefficients
		/*double sqrtNs = Math.sqrt(p.ns*p.ns - niNiSinThetaSinTheta);
		if (Double.isNaN(sqrtNs)) sqrtNs = 0;
		double sqrtNg = Math.sqrt(p.ng*p.ng - niNiSinThetaSinTheta);
		if (Double.isNaN(sqrtNg)) sqrtNg = 0;
		double ts1ts2 = 4.0*p.ni*cosTheta*sqrtNg;
		double tp1tp2 = ts1ts2;
		double constNs;
		ts1ts2 /= (p.ni*cosTheta + sqrtNg) * (sqrtNg + sqrtNs);
		tp1tp2 /= (p.ng*cosTheta + p.ni/p.ng*sqrtNg) * (p.ns/p.ng*sqrtNg + p.ng/p.ns*sqrtNs);
		constNs = tp1tp2*sqrtNs/p.ns; // used for I0 and I3
		*/
		
					
		//double OPD, OPD1, OPD2, OPD3, OPD4, OPD5;	// Optical path differences
		//double W, cosW, sinW;									// Phase aberration
		// Aguet's thesis, page 52
		//OPD1 = p.particleAxialPosition*Math.sqrt(ns*ns-niNiSinThetaSinTheta);
		//OPD2 = p.ti*Math.sqrt(p.ni*p.ni-niNiSinThetaSinTheta);
		//OPD3 = -p.ti0*Math.sqrt(p.ni0*p.ni0-niNISinThetaSinTheta);
		//OPD4 = p.tg*Math.sqrt(ng*ng-niNISinThetaSinTheta);
		//OPD5 = -p.tg0*Math.sqrt(ng0*ng0-niNISinThetaSinTheta);
		//OPD = OPD1+OPD2+OPD3+OPD4+OPD5;
		
		// Saving on computation time
		//OPD1 = p.particleAxialPosition*sqrtNs;
		//OPD2 = (p.ti-p.ti0)*Math.sqrt(p.ni*p.ni-niNiSinThetaSinTheta);
		//OPD = OPD1+OPD2;
		
		
		double k_tag= (2*Math.PI*p.ni/p.lambda);
		double x = k_tag*sinTheta*r;
		double J0 = Bessel.J0(x);
		double J1 = Bessel.J1(x);
		double J2 = (x==0)? 0: 2.0*J1/x + J0;
		
		double B0 = sqrtCosThetaSinTheta*(1+cosTheta)*J0;
		double B1 = sqrtCosThetaSinTheta*sinTheta*J1;
		double B2 = sqrtCosThetaSinTheta*(1-cosTheta)*J2;
		
		double OPD = p.defocus*cosTheta;
		double W = k_tag*OPD;
		double cosW = Math.cos(W);
		double sinW = Math.sin(W);
		
		double[][] I = new double[3][2];
		// The real part
		I[0][0] = B0*cosW;
		I[1][0] = B1*cosW;
		I[2][0] = B2*cosW;
		// The imaginary part
		I[0][1] = B0*sinW;
		I[1][1] = B1*sinW;
		I[2][1] = B2*sinW;
		
		return I;
	}
}

